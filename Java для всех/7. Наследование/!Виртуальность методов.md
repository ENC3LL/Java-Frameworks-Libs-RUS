[[JavaBase]]
%%Суперкласс%%
class Alpha{
%%Целочисленное поле%%
	int number;
%%Конструктор без аргументов%%
	Alpha(){
		set();
	}
%%Метод для отображения значения поля %%
	void show(){
		System.out.println("Класс Alpha");
		System.out.println("Поле number: "+number);
	}
%%Метод для присваивания значения полю %%
	void set(){
		number=100;
	}
%%В методе вызывается другой метод%%
	void display(){
		show();
	}
}
%%Подкласс%%
class Bravo extends Alpha{
%%Символьное поле%%
	char symbol;
%%Переопределение метода для отображения значения полей%%
	void show(){
		System.out.println("Класс Bravo");
		System.out.println("Поле number: "+number);
		System.out.println("Поле symbol: "+symbol);
	}
%%Переопределение метода для присваивания значений полям%%
	void set(){
		number=200;
		symbol='B';
	}
}
%%Главный класс%%
class Demo{
	public static void main(String[] args){
%%Создание объекта суперкласса%%
		Alpha A=new Alpha();
%%Вызов метода из объекта суперкласса %%
		A.display();
%%Создание объекта подкласса%%
		Bravo B=new Bravo();
%%Вызов метода из объекта подкласса%%
		B.display();
	}
}

Результат выполнения программы

Класс Alpha
Поле number: 100
Класс Bravo
Поле number: 200
Поле symbol: B

В представленном коде у нас есть суперкласс Alpha и подкласс Bravo, который наследует Alpha. Вот краткий разбор происходящего и что в этом необычного:

1. Суперкласс Alpha:

• Имеет целочисленное поле number.

• Определяет методы set(), show() и display().

• set() присваивает number значение 100.

• show() отображает значение number.

• display() вызывает метод show().

• В своем конструкторе вызывает метод set().

2. Подкласс Bravo:

• Добавляет символьное поле symbol.

• Переопределяет методы set() и show():

• set() теперь присваивает number значение 200 и symbol значение 'B'.

• show() отображает значения number и symbol.

• Не определяет свой собственный конструктор, поэтому использует конструктор по умолчанию, который неявно вызывает конструктор суперкласса Alpha.

3. Главный метод:

• Создает объект A типа Alpha и объект B типа Bravo.

• Вызывает display() для обоих объектов.

  

Что здесь необычного?

• Переопределенные методы вызываются из контекста суперкласса:

• При создании объекта B класса Bravo вызывается конструктор Alpha (так как Bravo не имеет собственного конструктора).

• В конструкторе Alpha вызывается метод set(). Однако, поскольку B является экземпляром Bravo, выполняется переопределенный метод set() из Bravo, который устанавливает number в 200 и symbol в 'B'.

• Это означает, что во время создания объекта B вызывается метод set() из подкласса до выполнения тела конструктора подкласса (которого в данном случае нет).

• Вызовы методов используют фактический тип объекта:

• Когда вызывается B.display():

• Используется метод display() из Alpha, потому что Bravo его не переопределяет.

• Внутри display() вызывается метод show().

• Хотя display() определен в Alpha, он вызывает переопределенный метод show() из Bravo, отображая оба значения number и symbol.

  

Основные выводы:

• Динамическая диспетчеризация методов:

• Java использует динамическую диспетчеризацию методов (полиморфизм во время выполнения), то есть метод, который будет выполнен, определяется фактическим типом объекта во время выполнения, а не типом ссылки или местом, откуда метод вызывается.

• Поэтому версии методов set() и show() из Bravo вызываются даже при их вызове из конструктора и методов Alpha.

• Конструкторы и переопределенные методы:

• Когда конструктор суперкласса вызывает метод, который переопределен в подклассе, выполняется версия метода из подкласса.

• Это может привести к неожиданному поведению, если переопределенный метод зависит от инициализации в подклассе, которая еще не произошла, что может вызвать ошибки или неправильные значения.

  

Последствия:

• Разработчики должны быть осторожны при вызове методов из конструкторов, особенно если эти методы могут быть переопределены.

• Часто рекомендуется избегать вызова переопределяемых методов из конструкторов, чтобы предотвратить непредвиденные побочные эффекты.

• Понимание динамической диспетчеризации методов важно для предсказания поведения переопределенных методов в иерархиях наследования.

  

Итог:

  

Необычность кода заключается в том, что методы, переопределенные в подклассе Bravo, вызываются из контекста суперкласса Alpha — как в конструкторе, так и в других методах — благодаря динамической диспетчеризации методов. Это демонстрирует, как переопределенные методы в Java связываются во время выполнения на основе фактического типа объекта, а не класса, в котором написан вызов метода.